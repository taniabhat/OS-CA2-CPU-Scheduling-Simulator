!pip install matplotlib numpy pandas
import matplotlib.pyplot as plt
import numpy as np
def fcfs(processes):
    processes.sort(key=lambda x: x[1])  # Sort by Arrival Time
    n = len(processes)
    completion_time = [0] * n
    waiting_time = [0] * n
    turnaround_time = [0] * n

    completion_time[0] = processes[0][1] + processes[0][2]
    for i in range(1, n):
        completion_time[i] = max(completion_time[i - 1], processes[i][1]) + processes[i][2]

    for i in range(n):
        turnaround_time[i] = completion_time[i] - processes[i][1]
        waiting_time[i] = turnaround_time[i] - processes[i][2]

    return processes, completion_time, waiting_time, turnaround_time


def sjf(processes):
    processes.sort(key=lambda x: (x[1], x[2]))  # Sort by Arrival Time, then Burst Time
    n = len(processes)
    completion_time = [0] * n
    waiting_time = [0] * n
    turnaround_time = [0] * n
    remaining_processes = processes[:]
    time = 0
    executed = []

    while remaining_processes:
        available = [p for p in remaining_processes if p[1] <= time]
        if available:
            available.sort(key=lambda x: x[2])  # Pick process with shortest burst time
            current = available[0]
            executed.append(current)
            time += current[2]
            completion_time[processes.index(current)] = time
            remaining_processes.remove(current)
        else:
            time += 1

    for i in range(n):
        turnaround_time[i] = completion_time[i] - processes[i][1]
        waiting_time[i] = turnaround_time[i] - processes[i][2]

    return executed, completion_time, waiting_time, turnaround_time


def round_robin(processes, quantum):
    n = len(processes)
    queue = processes[:]
    time = 0
    completion_time = [0] * n
    waiting_time = [0] * n
    turnaround_time = [0] * n
    remaining_burst = [p[2] for p in processes]

    while queue:
        p = queue.pop(0)
        index = processes.index(p)
        if remaining_burst[index] > quantum:
            time += quantum
            remaining_burst[index] -= quantum
            queue.append(p)
        else:
            time += remaining_burst[index]
            remaining_burst[index] = 0
            completion_time[index] = time

    for i in range(n):
        turnaround_time[i] = completion_time[i] - processes[i][1]
        waiting_time[i] = turnaround_time[i] - processes[i][2]

    return processes, completion_time, waiting_time, turnaround_time


def priority_scheduling(processes):
    processes.sort(key=lambda x: (x[3], x[1]))  # Sort by Priority, then Arrival Time
    return fcfs(processes)  # Same logic as FCFS

# Function to Visualize Gantt Chart
def draw_gantt_chart(processes, completion_time):
    fig, ax = plt.subplots(figsize=(8, 4))
    start_time = 0
    for i, p in enumerate(processes):
        ax.broken_barh([(start_time, p[2])], (10, 5), facecolors=('tab:blue'))
        ax.text(start_time + p[2] / 2, 12, f'P{p[0]}', ha='center', va='center', color='white', fontweight='bold')
        start_time = completion_time[i]

    ax.set_xlim(0, max(completion_time) + 1)
    ax.set_ylim(5, 20)
    ax.set_xlabel('Time')
    ax.set_yticks([])
    ax.set_title('Gantt Chart')
    plt.show() # Display the Gantt chart directly


def run_simulation(processes, algorithm, quantum=None):
    if algorithm == "FCFS":
        executed, completion_time, waiting_time, turnaround_time = fcfs(processes)
    elif algorithm == "SJF":
        executed, completion_time, waiting_time, turnaround_time = sjf(processes)
    elif algorithm == "Round Robin":
        executed, completion_time, waiting_time, turnaround_time = round_robin(processes, quantum)
    elif algorithm == "Priority Scheduling":
        executed, completion_time, waiting_time, turnaround_time = priority_scheduling(processes)
    else:
        print("Error: Invalid Algorithm Selected")  # Print error message
        return

    avg_wait = sum(waiting_time) / len(waiting_time)
    avg_turnaround = sum(turnaround_time) / len(turnaround_time)

    print(f"Avg Waiting Time: {avg_wait:.2f}\nAvg Turnaround Time: {avg_turnaround:.2f}")

    draw_gantt_chart(executed, completion_time)  # Call to draw Gantt Chart


# Example Usage:
processes = [
    [1, 0, 5, 0],  # [PID, Arrival Time, Burst Time, Priority]
    [2, 1, 3, 0],
    [3, 2, 8, 0],
    [4, 3, 6, 0]
]

run_simulation(processes, algorithm="FCFS")  
run_simulation(processes, algorithm="SJF")  
run_simulation(processes, algorithm="Round Robin", quantum=2)  
run_simulation(processes, algorithm="Priority Scheduling")

# Example Usage-2:
processes = [
    [1, 0, 8, 0],  # [PID, Arrival Time, Burst Time, Priority]
    [2, 4, 6, 0],
    [3, 1, ,5 0],
    [4, 2, 3, 0]
]

run_simulation(processes, algorithm="FCFS")  
run_simulation(processes, algorithm="SJF")  
run_simulation(processes, algorithm="Round Robin", quantum=3)  
run_simulation(processes, algorithm="Priority Scheduling")
